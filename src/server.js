import Express from 'express';
import React from 'react';
import ReactDOM from 'react-dom/server';
import config from './config';
import favicon from 'serve-favicon';
import compression from 'compression';
import httpProxy from 'http-proxy';
import path from 'path';
import createStore from './redux/create';
import ApiClient from './helpers/ApiClient';
import Html from './helpers/Html';
import PrettyError from 'pretty-error';
import http from 'http';
import https from 'https';
import fs from 'fs';

import { match } from 'react-router';
import { syncHistoryWithStore } from 'react-router-redux';
import { ReduxAsyncConnect, loadOnServer } from 'redux-async-connect';
import createHistory from 'react-router/lib/createMemoryHistory';
import {Provider} from 'react-redux';
import getRoutes from './routes';

var formidable = require('formidable');
var util = require('util');

const mysite = ('/root/wanchain/website/src/cert/wanchain.org.key'); //key
const mysiteCrt = ('/root/wanchain/website/src/cert/3bb55a3526ededcc.crt'); //
const gd1 = ('/root/wanchain/website/src/cert/gd_bundle-g2-g1.crt');

const targetUrl = 'http://' + config.apiHost + ':' + config.apiPort;
const pretty = new PrettyError();

const app = new Express();

// const debug = true;
const debug = false;

if (!debug) {
  const httpapp = new Express();
  const httpserver = new http.Server(httpapp);

  httpapp.use('*', function(req, res) {
    console.log("HTTP: " + req.url);
    return res.redirect(301, "https://" + req.headers["host"] + req.url);
  });
  httpapp.listen(80);

  const server = https.createServer({
    key: fs.readFileSync(mysite),
    cert: fs.readFileSync(mysiteCrt),
    ca: [fs.readFileSync(gd1)],
    requestCert: false,
    rejectUnauthorized: false
  }, app);

  const proxy = httpProxy.createProxyServer({
    target: targetUrl,
    ws: true
  });


  app.use(compression());
  app.use(favicon(path.join(__dirname, '..', 'static', 'favicon.ico')));

  app.use(Express.static(path.join(__dirname, '..', 'static')));

  /* ‰∏ä‰º†*/
  app.post('/upload',function(req, res){
    var reqMethod = req.method.toLowerCase();
    console.log('reqMethod', reqMethod);
    // Êñá‰ª∂Â∞ÜË¶Å‰∏ä‰º†Âà∞Âì™‰∏™Êñá‰ª∂Â§π‰∏ãÈù¢
    var uploadfolderpath = config.app.upload.prodpath;

    var server = config.app.upload.prodserver;

    console.log('Ë∑ØÁî± ' + req.url);

    // ----------------------Áî® '/upload' Ëøô‰∏™Ë∑ØÁî±Êù•Â§ÑÁêÜÊñá‰ª∂‰∏ä‰º†----------------------
    if (req.url === '/upload' && req.method.toLowerCase() === 'post') {

      res.setHeader("Access-Control-Allow-Origin", "*");
      res.setHeader("Access-Control-Allow-Headers", "X-Requested-With");
      res.setHeader("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");

      // ----- ÊÉÖÂÜµ1ÔºöË∑®ÂüüÊó∂ÔºåÂÖàÂèëÈÄÅ‰∏Ä‰∏™optionsËØ∑Ê±ÇÔºåÊ≠§Â§ÑË¶ÅËøîÂõû200 -----
      if (reqMethod === 'options') {
        console.log('options ËØ∑Ê±ÇÊó∂ÔºåËøîÂõû 200');

        // ËøîÂõûÁªìÊûú
        res.writeHead(200, {
          'Content-type': 'text/html'
        });
        res.end('options OK');
        return;
      }

      // ----- ÊÉÖÂÜµ2ÔºöÂèëÈÄÅpostËØ∑Ê±ÇÔºå‰∏ä‰º†ÂõæÁâá -----

      console.log('ÂÆö‰ΩçÂà∞ /upload Ë∑ØÁî±');

      // ‰ΩøÁî®Á¨¨‰∏âÊñπÁöÑ formidable Êèí‰ª∂ÂàùÂßãÂåñ‰∏Ä‰∏™ form ÂØπË±°
      var form = new formidable.IncomingForm();
      form.uploadDir = config.app.upload.produploadDir;

      // Â§ÑÁêÜ request
      form.parse(req, function (err, fields, files) {
        if (err) {
          return console.log('formidable, form.parse err');
        }

        console.log('formidable, form.parse ok');

        var item;

        // ËÆ°ÁÆó files ÈïøÂ∫¶
        var length = 0;
        for (item in files) {
          length++;
        }
        if (length === 0) {
          console.log('files no data');
          return;
        }

        for (item in files) {
          var file = files[item];
          // formidable ‰ºöÂ∞Ü‰∏ä‰º†ÁöÑÊñá‰ª∂Â≠òÂÇ®‰∏∫‰∏Ä‰∏™‰∏¥Êó∂Êñá‰ª∂ÔºåÁé∞Âú®Ëé∑ÂèñËøô‰∏™Êñá‰ª∂ÁöÑÁõÆÂΩï
          var tempfilepath = file.path;
          console.log('tempfilepath', tempfilepath);
          // Ëé∑ÂèñÊñá‰ª∂Á±ªÂûã
          var type = file.type;

          // Ëé∑ÂèñÊñá‰ª∂ÂêçÔºåÂπ∂Ê†πÊçÆÊñá‰ª∂ÂêçËé∑ÂèñÊâ©Â±ïÂêç
          var filename = file.name;
          var extname = filename.lastIndexOf('.') >= 0
              ? filename.slice(filename.lastIndexOf('.') - filename.length)
              : '';
          // Êñá‰ª∂ÂêçÊ≤°ÊúâÊâ©Â±ïÂêçÊó∂ÂÄôÔºåÂàô‰ªéÊñá‰ª∂Á±ªÂûã‰∏≠ÂèñÊâ©Â±ïÂêç
          if (extname === '' && type.indexOf('/') >= 0) {
            extname = '.' + type.split('/')[1];
          }
          // Â∞ÜÊñá‰ª∂ÂêçÈáçÊñ∞ËµãÂÄº‰∏∫‰∏Ä‰∏™ÈöèÊú∫Êï∞ÔºàÈÅøÂÖçÊñá‰ª∂ÈáçÂêçÔºâ
          filename = Math.random().toString().slice(2) + extname;

          // ÊûÑÂª∫Â∞ÜË¶ÅÂ≠òÂÇ®ÁöÑÊñá‰ª∂ÁöÑË∑ØÂæÑ
          var filenewpath = uploadfolderpath  + filename;

          // Â∞Ü‰∏¥Êó∂Êñá‰ª∂‰øùÂ≠ò‰∏∫Ê≠£ÂºèÁöÑÊñá‰ª∂
          fs.rename(tempfilepath, filenewpath, function (err) {
            // Â≠òÂÇ®ÁªìÊûú
            var result = '';

            if (err) {
              // ÂèëÁîüÈîôËØØ
              console.log('fs.rename err');
              result = 'error|save error';
            } else {
              // ‰øùÂ≠òÊàêÂäü
              console.log('fs.rename done');
              // ÊãºÊé•ÂõæÁâáurlÂú∞ÂùÄ
              result = server + 'upload' + '/' + filename;
            }

            // ËøîÂõûÁªìÊûú
            res.writeHead(200, {
              'Content-type': 'text/html'
            });
            res.end(result);
          }); // fs.rename
        } // for in
      });
    } else {
      // ---------------------- ÂÖ∂‰ªñË∑ØÁî±ÔºåÁõ¥Êé•‰Ωú‰∏∫ÈùôÊÄÅÊñá‰ª∂ËøîÂõûÔºåÂ¶ÇÈÄöËøáurlËé∑ÂèñÂõæÁâá ----------------------
      var pathname = url.parse(req.url).pathname;
      var filepath = path.join(__dirname, pathname);
      fs.readFile(filepath, function (err, file) {
        if (err) {
          res.writeHead(404);
          console.log('response file error: ' + filepath);
          res.end('404 NOT FOUND...');
          return;
        }
        if (filepath.slice(filepath.lastIndexOf('.') - filepath.length) === '.css') {
          // ÂÖºÂÆπIE
          res.writeHead('200', {'Content-type': 'text/css'});
        } else {
          res.writeHead('200');
        }
        console.log('response file success: ' + filepath);
        res.end(file);
      });
    }
  });

// Proxy to API server
  app.use('/api', (req, res) => {
    proxy.web(req, res, {target: targetUrl});
  });

  app.use('/ws', (req, res) => {
    proxy.web(req, res, {target: targetUrl + '/ws'});
  });

  server.on('upgrade', (req, socket, head) => {
    proxy.ws(req, socket, head);
  });

// added the error handling to avoid https://github.com/nodejitsu/node-http-proxy/issues/527
  proxy.on('error', (error, req, res) => {
    let json;
    if (error.code !== 'ECONNRESET') {
      console.error('proxy error', error);
    }
    if (!res.headersSent) {
      res.writeHead(500, {'content-type': 'application/json'});
    }

    json = {error: 'proxy_error', reason: error.message};
    res.end(JSON.stringify(json));
  });

  app.use((req, res) => {
    if (__DEVELOPMENT__) {
      // Do not cache webpack stats: the script file would change since
      // hot module replacement is enabled in the development env
      webpackIsomorphicTools.refresh();
    }
    const client = new ApiClient(req);
    const memoryHistory = createHistory(req.originalUrl);
    const store = createStore(memoryHistory, client);
    const history = syncHistoryWithStore(memoryHistory, store);

    function hydrateOnClient() {
      res.send('<!doctype html>\n' +
          ReactDOM.renderToString(<Html assets={webpackIsomorphicTools.assets()} store={store}/>));
    }

    if (__DISABLE_SSR__) {
      hydrateOnClient();
      return;
    }

    match({ history, routes: getRoutes(store), location: req.originalUrl }, (error, redirectLocation, renderProps) => {
      if (redirectLocation) {
        res.redirect(redirectLocation.pathname + redirectLocation.search);
      } else if (error) {
        console.error('ROUTER ERROR:', pretty.render(error));
        res.status(500);
        hydrateOnClient();
      } else if (renderProps) {
        loadOnServer({...renderProps, store, helpers: {client}}).then(() => {
          const component = (
              <Provider store={store} key="provider">
                <ReduxAsyncConnect {...renderProps} />
              </Provider>
          );

          res.status(200);

          global.navigator = {userAgent: req.headers['user-agent']};

          res.send('<!doctype html>\n' +
              ReactDOM.renderToString(<Html assets={webpackIsomorphicTools.assets()} component={component} store={store}/>));
        });
      } else {
        res.status(404).send('Not found');
      }
    });
  });

  if (config.port) {
    server.listen(config.port, (err) => {
      if (err) {
        console.error(err);
      }
      console.info('----\n==> ‚úÖ  %s is running in localhost, talking to API server on %s.', config.app.title, config.apiPort);
      console.info('==> üíª  Open http://%s:%s in a browser to view the app.', config.host, config.port);
    });
  } else {
    console.error('==>     ERROR: No PORT environment variable has been specified');
  }

} else {
  const server = new http.Server(app);

  const proxy = httpProxy.createProxyServer({
    target: targetUrl,
    ws: true
  });


  app.use(compression());
  app.use(favicon(path.join(__dirname, '..', 'static', 'favicon.ico')));

  app.use(Express.static(path.join(__dirname, '..', 'static')));

  /* ‰∏ä‰º†*/
  app.post('/upload',function(req, res){
    var reqMethod = req.method.toLowerCase();
    console.log('reqMethod', reqMethod);
    // Êñá‰ª∂Â∞ÜË¶Å‰∏ä‰º†Âà∞Âì™‰∏™Êñá‰ª∂Â§π‰∏ãÈù¢
    var uploadfolderpath = config.app.upload.devpath;

    var server = config.app.upload.devserver;

    console.log('Ë∑ØÁî± ' + req.url);

    // ----------------------Áî® '/upload' Ëøô‰∏™Ë∑ØÁî±Êù•Â§ÑÁêÜÊñá‰ª∂‰∏ä‰º†----------------------
    if (req.url === '/upload' && req.method.toLowerCase() === 'post') {

      res.setHeader("Access-Control-Allow-Origin", "*");
      res.setHeader("Access-Control-Allow-Headers", "X-Requested-With");
      res.setHeader("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");

      // ----- ÊÉÖÂÜµ1ÔºöË∑®ÂüüÊó∂ÔºåÂÖàÂèëÈÄÅ‰∏Ä‰∏™optionsËØ∑Ê±ÇÔºåÊ≠§Â§ÑË¶ÅËøîÂõû200 -----
      if (reqMethod === 'options') {
        console.log('options ËØ∑Ê±ÇÊó∂ÔºåËøîÂõû 200');

        // ËøîÂõûÁªìÊûú
        res.writeHead(200, {
          'Content-type': 'text/html'
        });
        res.end('options OK');
        return;
      }

      // ----- ÊÉÖÂÜµ2ÔºöÂèëÈÄÅpostËØ∑Ê±ÇÔºå‰∏ä‰º†ÂõæÁâá -----

      console.log('ÂÆö‰ΩçÂà∞ /upload Ë∑ØÁî±');

      // ‰ΩøÁî®Á¨¨‰∏âÊñπÁöÑ formidable Êèí‰ª∂ÂàùÂßãÂåñ‰∏Ä‰∏™ form ÂØπË±°
      var form = new formidable.IncomingForm();
      form.uploadDir = config.app.upload.devuploadDir;

      // Â§ÑÁêÜ request
      form.parse(req, function (err, fields, files) {
        if (err) {
          return console.log('formidable, form.parse err');
        }

        console.log('formidable, form.parse ok');

        var item;

        // ËÆ°ÁÆó files ÈïøÂ∫¶
        var length = 0;
        for (item in files) {
          length++;
        }
        if (length === 0) {
          console.log('files no data');
          return;
        }

        for (item in files) {
          var file = files[item];
          // formidable ‰ºöÂ∞Ü‰∏ä‰º†ÁöÑÊñá‰ª∂Â≠òÂÇ®‰∏∫‰∏Ä‰∏™‰∏¥Êó∂Êñá‰ª∂ÔºåÁé∞Âú®Ëé∑ÂèñËøô‰∏™Êñá‰ª∂ÁöÑÁõÆÂΩï
          var tempfilepath = file.path;
          console.log('tempfilepath', tempfilepath);
          // Ëé∑ÂèñÊñá‰ª∂Á±ªÂûã
          var type = file.type;

          // Ëé∑ÂèñÊñá‰ª∂ÂêçÔºåÂπ∂Ê†πÊçÆÊñá‰ª∂ÂêçËé∑ÂèñÊâ©Â±ïÂêç
          var filename = file.name;
          var extname = filename.lastIndexOf('.') >= 0
              ? filename.slice(filename.lastIndexOf('.') - filename.length)
              : '';
          // Êñá‰ª∂ÂêçÊ≤°ÊúâÊâ©Â±ïÂêçÊó∂ÂÄôÔºåÂàô‰ªéÊñá‰ª∂Á±ªÂûã‰∏≠ÂèñÊâ©Â±ïÂêç
          if (extname === '' && type.indexOf('/') >= 0) {
            extname = '.' + type.split('/')[1];
          }
          // Â∞ÜÊñá‰ª∂ÂêçÈáçÊñ∞ËµãÂÄº‰∏∫‰∏Ä‰∏™ÈöèÊú∫Êï∞ÔºàÈÅøÂÖçÊñá‰ª∂ÈáçÂêçÔºâ
          filename = Math.random().toString().slice(2) + extname;

          // ÊûÑÂª∫Â∞ÜË¶ÅÂ≠òÂÇ®ÁöÑÊñá‰ª∂ÁöÑË∑ØÂæÑ
          var filenewpath = uploadfolderpath  + filename;

          // Â∞Ü‰∏¥Êó∂Êñá‰ª∂‰øùÂ≠ò‰∏∫Ê≠£ÂºèÁöÑÊñá‰ª∂
          fs.rename(tempfilepath, filenewpath, function (err) {
            // Â≠òÂÇ®ÁªìÊûú
            var result = '';

            if (err) {
              // ÂèëÁîüÈîôËØØ
              console.log('fs.rename err');
              result = 'error|save error';
            } else {
              // ‰øùÂ≠òÊàêÂäü
              console.log('fs.rename done');
              // ÊãºÊé•ÂõæÁâáurlÂú∞ÂùÄ
              result = server + 'upload' + '/' + filename;
            }

            // ËøîÂõûÁªìÊûú
            res.writeHead(200, {
              'Content-type': 'text/html'
            });
            res.end(result);
          }); // fs.rename
        } // for in
      });
    } else {
      // ---------------------- ÂÖ∂‰ªñË∑ØÁî±ÔºåÁõ¥Êé•‰Ωú‰∏∫ÈùôÊÄÅÊñá‰ª∂ËøîÂõûÔºåÂ¶ÇÈÄöËøáurlËé∑ÂèñÂõæÁâá ----------------------
      var pathname = url.parse(req.url).pathname;
      var filepath = path.join(__dirname, pathname);
      fs.readFile(filepath, function (err, file) {
        if (err) {
          res.writeHead(404);
          console.log('response file error: ' + filepath);
          res.end('404 NOT FOUND...');
          return;
        }
        if (filepath.slice(filepath.lastIndexOf('.') - filepath.length) === '.css') {
          // ÂÖºÂÆπIE
          res.writeHead('200', {'Content-type': 'text/css'});
        } else {
          res.writeHead('200');
        }
        console.log('response file success: ' + filepath);
        res.end(file);
      });
    }
  });

// Proxy to API server
  app.use('/api', (req, res) => {
    proxy.web(req, res, {target: targetUrl});
  });

  app.use('/ws', (req, res) => {
    proxy.web(req, res, {target: targetUrl + '/ws'});
  });

  server.on('upgrade', (req, socket, head) => {
    proxy.ws(req, socket, head);
  });

// added the error handling to avoid https://github.com/nodejitsu/node-http-proxy/issues/527
  proxy.on('error', (error, req, res) => {
    let json;
    if (error.code !== 'ECONNRESET') {
      console.error('proxy error', error);
    }
    if (!res.headersSent) {
      res.writeHead(500, {'content-type': 'application/json'});
    }

    json = {error: 'proxy_error', reason: error.message};
    res.end(JSON.stringify(json));
  });

  app.use((req, res) => {
    if (__DEVELOPMENT__) {
      // Do not cache webpack stats: the script file would change since
      // hot module replacement is enabled in the development env
      webpackIsomorphicTools.refresh();
    }
    const client = new ApiClient(req);
    const memoryHistory = createHistory(req.originalUrl);
    const store = createStore(memoryHistory, client);
    const history = syncHistoryWithStore(memoryHistory, store);

    function hydrateOnClient() {
      res.send('<!doctype html>\n' +
          ReactDOM.renderToString(<Html assets={webpackIsomorphicTools.assets()} store={store}/>));
    }

    if (__DISABLE_SSR__) {
      hydrateOnClient();
      return;
    }

    match({ history, routes: getRoutes(store), location: req.originalUrl }, (error, redirectLocation, renderProps) => {
      if (redirectLocation) {
        res.redirect(redirectLocation.pathname + redirectLocation.search);
      } else if (error) {
        console.error('ROUTER ERROR:', pretty.render(error));
        res.status(500);
        hydrateOnClient();
      } else if (renderProps) {
        loadOnServer({...renderProps, store, helpers: {client}}).then(() => {
          const component = (
              <Provider store={store} key="provider">
                <ReduxAsyncConnect {...renderProps} />
              </Provider>
          );

          res.status(200);

          global.navigator = {userAgent: req.headers['user-agent']};

          res.send('<!doctype html>\n' +
              ReactDOM.renderToString(<Html assets={webpackIsomorphicTools.assets()} component={component} store={store}/>));
        });
      } else {
        res.status(404).send('Not found');
      }
    });
  });

  if (config.port) {
    server.listen(8080, (err) => {
      if (err) {
        console.error(err);
      }
      console.info('----\n==> ‚úÖ  %s is running in localhost, talking to API server on %s.', config.app.title, config.apiPort);
      console.info('==> üíª  Open http://%s:%s in a browser to view the app.', config.host, 8080);
    });
  } else {
    console.error('==>     ERROR: No PORT environment variable has been specified');
  }
}



